CREATE OR REPLACE PACKAGE BODY EMPLOYEE_CP
/*
| Generated by or retrieved from Qnxo - DO NOT MODIFY!
| Qnxo - "Get it right, do it fast" - www.qnxo.com
| Qnxo Universal ID: 657bd35e-2e48-4cd4-b14e-41420b8433b3
| Created On: April     04, 2005 07:31:47 Created By: QNXO_DEMO
*/
IS

   e_null_column_value EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_null_column_value, -1400);
   e_existing_fky_reference EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_existing_fky_reference, -2266);
   e_check_constraint_failure EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_check_constraint_failure, -2290);
   e_no_parent_key EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_no_parent_key, -2291);
   e_child_record_found EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_child_record_found, -2292);
   e_forall_error EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_forall_error, -24381);
   --
   -- Defined for backward compatibilty.
   e_integ_constraint_failure EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_integ_constraint_failure, -2291);


    -- Private utilities
   PROCEDURE get_constraint_info (
      owner_out OUT ALL_CONSTRAINTS.OWNER%TYPE
     ,name_out OUT ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE)
   IS
      l_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
      dotloc INTEGER;
      leftloc INTEGER;
      l_owner ALL_CONSTRAINTS.OWNER%TYPE;
      l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
   BEGIN
      dotloc  := INSTR (l_errm,'.');
      leftloc := INSTR (l_errm,'(');
      owner_out := SUBSTR (l_errm, leftloc+1, dotloc-leftloc-1);
      name_out  := SUBSTR (l_errm, dotloc+1, INSTR (l_errm,')')-dotloc-1);
   END get_constraint_info;

   -- Public programs

   PROCEDURE ins (
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      last_name_in IN EMPLOYEE_TP.LAST_NAME_t DEFAULT NULL,
      first_name_in IN EMPLOYEE_TP.FIRST_NAME_t DEFAULT NULL,
      middle_initial_in IN EMPLOYEE_TP.MIDDLE_INITIAL_t DEFAULT NULL,
      job_id_in IN EMPLOYEE_TP.JOB_ID_t DEFAULT NULL,
      manager_id_in IN EMPLOYEE_TP.MANAGER_ID_t DEFAULT NULL,
      hire_date_in IN EMPLOYEE_TP.HIRE_DATE_t DEFAULT SYSDATE,
      salary_in IN EMPLOYEE_TP.SALARY_t DEFAULT NULL,
      commission_in IN EMPLOYEE_TP.COMMISSION_t DEFAULT NULL,
      department_id_in IN EMPLOYEE_TP.DEPARTMENT_ID_t DEFAULT NULL,
      empno_in IN EMPLOYEE_TP.EMPNO_t DEFAULT NULL,
      ename_in IN EMPLOYEE_TP.ENAME_t DEFAULT NULL,
      created_by_in IN EMPLOYEE_TP.CREATED_BY_t DEFAULT USER,
      created_on_in IN EMPLOYEE_TP.CREATED_ON_t DEFAULT SYSDATE,
      changed_by_in IN EMPLOYEE_TP.CHANGED_BY_t DEFAULT USER,
      changed_on_in IN EMPLOYEE_TP.CHANGED_ON_t DEFAULT SYSDATE,
      handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution (program_name_in => 'ins');
      END IF;
      INSERT INTO EMPLOYEE (
         EMPLOYEE_ID,
         LAST_NAME,
         FIRST_NAME,
         MIDDLE_INITIAL,
         JOB_ID,
         MANAGER_ID,
         HIRE_DATE,
         SALARY,
         COMMISSION,
         DEPARTMENT_ID,
         EMPNO,
         ENAME,
         CREATED_BY,
         CREATED_ON,
         CHANGED_BY,
         CHANGED_ON
         )
      VALUES (
         employee_id_in,
         last_name_in,
         first_name_in,
         middle_initial_in,
         job_id_in,
         manager_id_in,
         hire_date_in,
         salary_in,
         commission_in,
         department_id_in,
         empno_in,
         ename_in,
         created_by_in,
         created_on_in,
         changed_by_in,
         changed_on_in
         );
      IF qd_runtime.trace_enabled THEN
        qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF FALSE THEN NULL; -- Placeholder in case no unique indexes
           ELSIF l_name = 'I_EMPLOYEE_NAME'
           THEN
              qd_runtime.register_error (
                 error_name_in => 'DUPLICATE-VALUE'
                ,err_instance_id_out => l_err_instance_id
                ,text_in => 'Violation of unique index "I_EMPLOYEE_NAME"'
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'OWNER'
                ,value_in => l_owner
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'CONSTRAINT_NAME'
                ,value_in => l_name
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'TABLE_NAME'
                ,value_in => 'EMPLOYEE'
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'LAST_NAME'
                ,value_in => last_name_in
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'FIRST_NAME'
                ,value_in => first_name_in
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'MIDDLE_INITIAL'
                ,value_in => middle_initial_in
                ,validate_in => FALSE
                );
              qd_runtime.raise_error_instance (
                    err_instance_id_in => l_err_instance_id);
           ELSE
              qd_runtime.raise_error (
                    error_name_in => 'DUPLICATE-VALUE'
                    ,name1_in => 'OWNER'
                    ,value1_in => l_owner
                    ,name2_in => 'CONSTRAINT_NAME'
                    ,value2_in => l_name
                    ,name3_in => 'TABLE_NAME'
                    ,value3_in => 'EMPLOYEE');
           END IF;
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END ins;

   PROCEDURE ins (
      rec_in IN EMPLOYEE_TP.EMPLOYEE_rt
     ,gen_pky_in IN BOOLEAN DEFAULT FALSE
     ,sequence_in IN VARCHAR2 := NULL
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_rec EMPLOYEE_TP.EMPLOYEE_rt := rec_in;
   BEGIN
      IF gen_pky_in THEN
         l_rec.EMPLOYEE_ID := next_key (sequence_in);
      END IF;
      ins (
         employee_id_in => l_rec.EMPLOYEE_ID,
         last_name_in => l_rec.LAST_NAME,
         first_name_in => l_rec.FIRST_NAME,
         middle_initial_in => l_rec.MIDDLE_INITIAL,
         job_id_in => l_rec.JOB_ID,
         manager_id_in => l_rec.MANAGER_ID,
         hire_date_in => l_rec.HIRE_DATE,
         salary_in => l_rec.SALARY,
         commission_in => l_rec.COMMISSION,
         department_id_in => l_rec.DEPARTMENT_ID,
         empno_in => l_rec.EMPNO,
         ename_in => l_rec.ENAME,
         created_by_in => l_rec.CREATED_BY,
         created_on_in => l_rec.CREATED_ON,
         changed_by_in => l_rec.CHANGED_BY,
         changed_on_in => l_rec.CHANGED_ON,
         handle_error_in => handle_error_in
         );
   END ins;

   FUNCTION next_key (sequence_in IN VARCHAR2 := NULL) RETURN EMPLOYEE_TP.EMPLOYEE_ID_t
   IS
      retval EMPLOYEE_TP.EMPLOYEE_ID_t;
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution (program_name_in => 'next_key');
      END IF;
      IF sequence_in IS NULL
      THEN
         SELECT employee_seq.NEXTVAL INTO retval FROM dual;
      ELSE
         EXECUTE IMMEDIATE
            'SELECT ' || sequence_in || '.NEXTVAL FROM dual'
            INTO retval;
      END IF;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
      RETURN retval;
   EXCEPTION
      WHEN OTHERS THEN
        qd_runtime.start_exception_handling;
        qd_runtime.raise_error (
           error_name_in => 'SEQUENCE-GENERATION-FAILURE'
           ,name1_in => 'SEQUENCE'
           ,value1_in => NVL (sequence_in, 'employee_seq')
           );
   END next_key;

   PROCEDURE ins (
      last_name_in IN EMPLOYEE_TP.LAST_NAME_t DEFAULT NULL,
      first_name_in IN EMPLOYEE_TP.FIRST_NAME_t DEFAULT NULL,
      middle_initial_in IN EMPLOYEE_TP.MIDDLE_INITIAL_t DEFAULT NULL,
      job_id_in IN EMPLOYEE_TP.JOB_ID_t DEFAULT NULL,
      manager_id_in IN EMPLOYEE_TP.MANAGER_ID_t DEFAULT NULL,
      hire_date_in IN EMPLOYEE_TP.HIRE_DATE_t DEFAULT SYSDATE,
      salary_in IN EMPLOYEE_TP.SALARY_t DEFAULT NULL,
      commission_in IN EMPLOYEE_TP.COMMISSION_t DEFAULT NULL,
      department_id_in IN EMPLOYEE_TP.DEPARTMENT_ID_t DEFAULT NULL,
      empno_in IN EMPLOYEE_TP.EMPNO_t DEFAULT NULL,
      ename_in IN EMPLOYEE_TP.ENAME_t DEFAULT NULL,
      created_by_in IN EMPLOYEE_TP.CREATED_BY_t DEFAULT USER,
      created_on_in IN EMPLOYEE_TP.CREATED_ON_t DEFAULT SYSDATE,
      changed_by_in IN EMPLOYEE_TP.CHANGED_BY_t DEFAULT USER,
      changed_on_in IN EMPLOYEE_TP.CHANGED_ON_t DEFAULT SYSDATE,
      employee_id_out IN OUT EMPLOYEE_TP.EMPLOYEE_ID_t,
      handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_pky EMPLOYEE_TP.EMPLOYEE_ID_t := next_key;
   BEGIN
      ins (
         employee_id_in => l_pky,
         last_name_in => last_name_in,
         first_name_in => first_name_in,
         middle_initial_in => middle_initial_in,
         job_id_in => job_id_in,
         manager_id_in => manager_id_in,
         hire_date_in => hire_date_in,
         salary_in => salary_in,
         commission_in => commission_in,
         department_id_in => department_id_in,
         empno_in => empno_in,
         ename_in => ename_in,
         created_by_in => created_by_in,
         created_on_in => created_on_in,
         changed_by_in => changed_by_in,
         changed_on_in => changed_on_in,
         handle_error_in => handle_error_in
         );
      employee_id_out := l_pky;
   END ins;

   FUNCTION ins (
      last_name_in IN EMPLOYEE_TP.LAST_NAME_t DEFAULT NULL,
      first_name_in IN EMPLOYEE_TP.FIRST_NAME_t DEFAULT NULL,
      middle_initial_in IN EMPLOYEE_TP.MIDDLE_INITIAL_t DEFAULT NULL,
      job_id_in IN EMPLOYEE_TP.JOB_ID_t DEFAULT NULL,
      manager_id_in IN EMPLOYEE_TP.MANAGER_ID_t DEFAULT NULL,
      hire_date_in IN EMPLOYEE_TP.HIRE_DATE_t DEFAULT SYSDATE,
      salary_in IN EMPLOYEE_TP.SALARY_t DEFAULT NULL,
      commission_in IN EMPLOYEE_TP.COMMISSION_t DEFAULT NULL,
      department_id_in IN EMPLOYEE_TP.DEPARTMENT_ID_t DEFAULT NULL,
      empno_in IN EMPLOYEE_TP.EMPNO_t DEFAULT NULL,
      ename_in IN EMPLOYEE_TP.ENAME_t DEFAULT NULL,
      created_by_in IN EMPLOYEE_TP.CREATED_BY_t DEFAULT USER,
      created_on_in IN EMPLOYEE_TP.CREATED_ON_t DEFAULT SYSDATE,
      changed_by_in IN EMPLOYEE_TP.CHANGED_BY_t DEFAULT USER,
      changed_on_in IN EMPLOYEE_TP.CHANGED_ON_t DEFAULT SYSDATE,
      handle_error_in IN BOOLEAN := TRUE
   )
      RETURN
         EMPLOYEE_TP.EMPLOYEE_ID_t
   IS
      l_pky EMPLOYEE_TP.EMPLOYEE_ID_t := next_key;
   BEGIN
      ins (
         employee_id_in => l_pky,
         last_name_in => last_name_in,
         first_name_in => first_name_in,
         middle_initial_in => middle_initial_in,
         job_id_in => job_id_in,
         manager_id_in => manager_id_in,
         hire_date_in => hire_date_in,
         salary_in => salary_in,
         commission_in => commission_in,
         department_id_in => department_id_in,
         empno_in => empno_in,
         ename_in => ename_in,
         created_by_in => created_by_in,
         created_on_in => created_on_in,
         changed_by_in => changed_by_in,
         changed_on_in => changed_on_in,
         handle_error_in => handle_error_in
         );
      RETURN l_pky;
   END ins;

    PROCEDURE ins (
      last_name_in IN EMPLOYEE_TP.LAST_NAME_t DEFAULT NULL,
      first_name_in IN EMPLOYEE_TP.FIRST_NAME_t DEFAULT NULL,
      middle_initial_in IN EMPLOYEE_TP.MIDDLE_INITIAL_t DEFAULT NULL,
      job_id_in IN EMPLOYEE_TP.JOB_ID_t DEFAULT NULL,
      manager_id_in IN EMPLOYEE_TP.MANAGER_ID_t DEFAULT NULL,
      hire_date_in IN EMPLOYEE_TP.HIRE_DATE_t DEFAULT SYSDATE,
      salary_in IN EMPLOYEE_TP.SALARY_t DEFAULT NULL,
      commission_in IN EMPLOYEE_TP.COMMISSION_t DEFAULT NULL,
      department_id_in IN EMPLOYEE_TP.DEPARTMENT_ID_t DEFAULT NULL,
      empno_in IN EMPLOYEE_TP.EMPNO_t DEFAULT NULL,
      ename_in IN EMPLOYEE_TP.ENAME_t DEFAULT NULL,
      created_by_in IN EMPLOYEE_TP.CREATED_BY_t DEFAULT USER,
      created_on_in IN EMPLOYEE_TP.CREATED_ON_t DEFAULT SYSDATE,
      changed_by_in IN EMPLOYEE_TP.CHANGED_BY_t DEFAULT USER,
      changed_on_in IN EMPLOYEE_TP.CHANGED_ON_t DEFAULT SYSDATE,
      handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_pky EMPLOYEE_TP.EMPLOYEE_ID_t := next_key;
   BEGIN
      ins (
         employee_id_in => l_pky,
         last_name_in => last_name_in,
         first_name_in => first_name_in,
         middle_initial_in => middle_initial_in,
         job_id_in => job_id_in,
         manager_id_in => manager_id_in,
         hire_date_in => hire_date_in,
         salary_in => salary_in,
         commission_in => commission_in,
         department_id_in => department_id_in,
         empno_in => empno_in,
         ename_in => ename_in,
         created_by_in => created_by_in,
         created_on_in => created_on_in,
         changed_by_in => changed_by_in,
         changed_on_in => changed_on_in,
         handle_error_in => handle_error_in
         );
   END ins;

    PROCEDURE ins (
      rows_in IN EMPLOYEE_TP.EMPLOYEE_tc
     ,rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_employee_id EMPLOYEE_TP.EMPLOYEE_ID_cc;
      l_last_name EMPLOYEE_TP.LAST_NAME_cc;
      l_first_name EMPLOYEE_TP.FIRST_NAME_cc;
      l_middle_initial EMPLOYEE_TP.MIDDLE_INITIAL_cc;
      l_job_id EMPLOYEE_TP.JOB_ID_cc;
      l_manager_id EMPLOYEE_TP.MANAGER_ID_cc;
      l_hire_date EMPLOYEE_TP.HIRE_DATE_cc;
      l_salary EMPLOYEE_TP.SALARY_cc;
      l_commission EMPLOYEE_TP.COMMISSION_cc;
      l_department_id EMPLOYEE_TP.DEPARTMENT_ID_cc;
      l_empno EMPLOYEE_TP.EMPNO_cc;
      l_ename EMPLOYEE_TP.ENAME_cc;
      l_created_by EMPLOYEE_TP.CREATED_BY_cc;
      l_created_on EMPLOYEE_TP.CREATED_ON_cc;
      l_changed_by EMPLOYEE_TP.CHANGED_BY_cc;
      l_changed_on EMPLOYEE_TP.CHANGED_ON_cc;
      l_progress VARCHAR2(1000);
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'ins');
      END IF;
      IF rows_in.COUNT = 0
      THEN
         rows_out := 0;
      ELSE
         l_progress := 'Populate l_employee_id collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying EMPLOYEE_ID to column collection row ' || indx;
            l_employee_id(indx) := rows_in (indx).EMPLOYEE_ID;
         END LOOP;
         l_progress := 'Populate l_last_name collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying LAST_NAME to column collection row ' || indx;
            l_last_name(indx) := rows_in (indx).LAST_NAME;
         END LOOP;
         l_progress := 'Populate l_first_name collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying FIRST_NAME to column collection row ' || indx;
            l_first_name(indx) := rows_in (indx).FIRST_NAME;
         END LOOP;
         l_progress := 'Populate l_middle_initial collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying MIDDLE_INITIAL to column collection row ' || indx;
            l_middle_initial(indx) := rows_in (indx).MIDDLE_INITIAL;
         END LOOP;
         l_progress := 'Populate l_job_id collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying JOB_ID to column collection row ' || indx;
            l_job_id(indx) := rows_in (indx).JOB_ID;
         END LOOP;
         l_progress := 'Populate l_manager_id collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying MANAGER_ID to column collection row ' || indx;
            l_manager_id(indx) := rows_in (indx).MANAGER_ID;
         END LOOP;
         l_progress := 'Populate l_hire_date collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying HIRE_DATE to column collection row ' || indx;
            l_hire_date(indx) := rows_in (indx).HIRE_DATE;
         END LOOP;
         l_progress := 'Populate l_salary collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying SALARY to column collection row ' || indx;
            l_salary(indx) := rows_in (indx).SALARY;
         END LOOP;
         l_progress := 'Populate l_commission collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying COMMISSION to column collection row ' || indx;
            l_commission(indx) := rows_in (indx).COMMISSION;
         END LOOP;
         l_progress := 'Populate l_department_id collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying DEPARTMENT_ID to column collection row ' || indx;
            l_department_id(indx) := rows_in (indx).DEPARTMENT_ID;
         END LOOP;
         l_progress := 'Populate l_empno collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying EMPNO to column collection row ' || indx;
            l_empno(indx) := rows_in (indx).EMPNO;
         END LOOP;
         l_progress := 'Populate l_ename collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying ENAME to column collection row ' || indx;
            l_ename(indx) := rows_in (indx).ENAME;
         END LOOP;
         l_progress := 'Populate l_created_by collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying CREATED_BY to column collection row ' || indx;
            l_created_by(indx) := rows_in (indx).CREATED_BY;
         END LOOP;
         l_progress := 'Populate l_created_on collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying CREATED_ON to column collection row ' || indx;
            l_created_on(indx) := rows_in (indx).CREATED_ON;
         END LOOP;
         l_progress := 'Populate l_changed_by collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying CHANGED_BY to column collection row ' || indx;
            l_changed_by(indx) := rows_in (indx).CHANGED_BY;
         END LOOP;
         l_progress := 'Populate l_changed_on collection';
         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying CHANGED_ON to column collection row ' || indx;
            l_changed_on(indx) := rows_in (indx).CHANGED_ON;
         END LOOP;
      l_progress := 'Execute FORALL for ' || rows_in.COUNT || ' rows';
         FORALL indx IN rows_in.FIRST .. rows_in.LAST
            SAVE EXCEPTIONS
            INSERT INTO EMPLOYEE (
               EMPLOYEE_ID,
               LAST_NAME,
               FIRST_NAME,
               MIDDLE_INITIAL,
               JOB_ID,
               MANAGER_ID,
               HIRE_DATE,
               SALARY,
               COMMISSION,
               DEPARTMENT_ID,
               EMPNO,
               ENAME,
               CREATED_BY,
               CREATED_ON,
               CHANGED_BY,
               CHANGED_ON
               )
            VALUES (
               l_employee_id(indx),
               l_last_name(indx),
               l_first_name(indx),
               l_middle_initial(indx),
               l_job_id(indx),
               l_manager_id(indx),
               l_hire_date(indx),
               l_salary(indx),
               l_commission(indx),
               l_department_id(indx),
               l_empno(indx),
               l_ename(indx),
               l_created_by(indx),
               l_created_on(indx),
               l_changed_by(indx),
               l_changed_on(indx)
               );
         l_employee_id.DELETE;
         l_last_name.DELETE;
         l_first_name.DELETE;
         l_middle_initial.DELETE;
         l_job_id.DELETE;
         l_manager_id.DELETE;
         l_hire_date.DELETE;
         l_salary.DELETE;
         l_commission.DELETE;
         l_department_id.DELETE;
         l_empno.DELETE;
         l_ename.DELETE;
         l_created_by.DELETE;
         l_created_on.DELETE;
         l_changed_by.DELETE;
         l_changed_on.DELETE;
         rows_out := SQL%ROWCOUNT;
      END IF;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION
     WHEN e_forall_error
     THEN
        -- In Oracle9i and above, SAVE EXCEPTIONS will direct control
        -- here if any error occurs. We can then save all the error
        -- information out to the error instance.
       qd_runtime.start_exception_handling;
       IF NOT handle_error_in THEN RAISE;
       ELSE
          <<bulk_handler>>
          DECLARE
             l_err_instance_id qd_err_instance_tp.id_t;
          BEGIN
             -- For each error, write to the log.
             FOR indx IN 1 .. SQL%BULK_EXCEPTIONS.COUNT
             LOOP
                qd_runtime.register_error (
                    error_name_in => 'FORALL-INSERT-FAILURE'
                   ,err_instance_id_out => l_err_instance_id
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'BINDING_ROW_' || indx
                  ,value_in => SQL%BULK_EXCEPTIONS (indx).ERROR_INDEX
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'ERROR_AT_ROW_' || indx
                  ,value_in => SQL%BULK_EXCEPTIONS (indx).ERROR_CODE
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'EMPLOYEE_ID'
                  ,value_in => l_employee_id(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'LAST_NAME'
                  ,value_in => l_last_name(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'FIRST_NAME'
                  ,value_in => l_first_name(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'MIDDLE_INITIAL'
                  ,value_in => l_middle_initial(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'JOB_ID'
                  ,value_in => l_job_id(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'MANAGER_ID'
                  ,value_in => l_manager_id(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'HIRE_DATE'
                  ,value_in => l_hire_date(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'SALARY'
                  ,value_in => l_salary(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'COMMISSION'
                  ,value_in => l_commission(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'DEPARTMENT_ID'
                  ,value_in => l_department_id(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'EMPNO'
                  ,value_in => l_empno(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'ENAME'
                  ,value_in => l_ename(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'CREATED_BY'
                  ,value_in => l_created_by(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'CREATED_ON'
                  ,value_in => l_created_on(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'CHANGED_BY'
                  ,value_in => l_changed_by(indx)
                  ,validate_in => FALSE
                );
                qd_runtime.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'CHANGED_ON'
                  ,value_in => l_changed_on(indx)
                  ,validate_in => FALSE
                );
             END LOOP;
          END bulk_handler;
        END IF;
     WHEN OTHERS
     THEN
       qd_runtime.start_exception_handling;
       IF NOT handle_error_in THEN RAISE;
       ELSE
       qd_runtime.raise_error(
          error_name_in => 'FORALL-INSERT-FAILURE'
          ,name1_in => 'TABLE_NAME'
          ,value1_in => 'EMPLOYEE'
          ,name2_in => 'ROW_COUNT'
          ,value2_in => rows_in.COUNT
          ,name3_in => 'PROGRESS_INDICATOR'
          ,value3_in => l_progress
           );
       END IF;
   END ins;
   PROCEDURE upd (
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      last_name_in IN EMPLOYEE_TP.LAST_NAME_t DEFAULT NULL,
      first_name_in IN EMPLOYEE_TP.FIRST_NAME_t DEFAULT NULL,
      middle_initial_in IN EMPLOYEE_TP.MIDDLE_INITIAL_t DEFAULT NULL,
      job_id_in IN EMPLOYEE_TP.JOB_ID_t DEFAULT NULL,
      manager_id_in IN EMPLOYEE_TP.MANAGER_ID_t DEFAULT NULL,
      hire_date_in IN EMPLOYEE_TP.HIRE_DATE_t DEFAULT NULL,
      salary_in IN EMPLOYEE_TP.SALARY_t DEFAULT NULL,
      commission_in IN EMPLOYEE_TP.COMMISSION_t DEFAULT NULL,
      department_id_in IN EMPLOYEE_TP.DEPARTMENT_ID_t DEFAULT NULL,
      empno_in IN EMPLOYEE_TP.EMPNO_t DEFAULT NULL,
      ename_in IN EMPLOYEE_TP.ENAME_t DEFAULT NULL,
      created_by_in IN EMPLOYEE_TP.CREATED_BY_t DEFAULT NULL,
      created_on_in IN EMPLOYEE_TP.CREATED_ON_t DEFAULT NULL,
      changed_by_in IN EMPLOYEE_TP.CHANGED_BY_t DEFAULT NULL,
      changed_on_in IN EMPLOYEE_TP.CHANGED_ON_t DEFAULT NULL,
      rows_out OUT PLS_INTEGER,
      ignore_if_null_in IN BOOLEAN := FALSE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'upd');
      END IF;
      IF NVL (ignore_if_null_in, FALSE)
      THEN
         -- Set any columns to their current values
         -- if incoming value is NULL.
         -- Put WHEN clause on column-level triggers!
         UPDATE EMPLOYEE SET
            LAST_NAME = NVL (last_name_in, LAST_NAME),
            FIRST_NAME = NVL (first_name_in, FIRST_NAME),
            MIDDLE_INITIAL = NVL (middle_initial_in, MIDDLE_INITIAL),
            JOB_ID = NVL (job_id_in, JOB_ID),
            MANAGER_ID = NVL (manager_id_in, MANAGER_ID),
            HIRE_DATE = NVL (hire_date_in, HIRE_DATE),
            SALARY = NVL (salary_in, SALARY),
            COMMISSION = NVL (commission_in, COMMISSION),
            DEPARTMENT_ID = NVL (department_id_in, DEPARTMENT_ID),
            EMPNO = NVL (empno_in, EMPNO),
            ENAME = NVL (ename_in, ENAME),
            CREATED_BY = NVL (created_by_in, CREATED_BY),
            CREATED_ON = NVL (created_on_in, CREATED_ON),
            CHANGED_BY = NVL (changed_by_in, CHANGED_BY),
            CHANGED_ON = NVL (changed_on_in, CHANGED_ON)
          WHERE
             EMPLOYEE_ID = employee_id_in
         ;
      ELSE
         UPDATE EMPLOYEE SET
            LAST_NAME = last_name_in,
            FIRST_NAME = first_name_in,
            MIDDLE_INITIAL = middle_initial_in,
            JOB_ID = job_id_in,
            MANAGER_ID = manager_id_in,
            HIRE_DATE = hire_date_in,
            SALARY = salary_in,
            COMMISSION = commission_in,
            DEPARTMENT_ID = department_id_in,
            EMPNO = empno_in,
            ENAME = ename_in,
            CREATED_BY = created_by_in,
            CREATED_ON = created_on_in,
            CHANGED_BY = changed_by_in,
            CHANGED_ON = changed_on_in
          WHERE
             EMPLOYEE_ID = employee_id_in
         ;
      END IF;
      rows_out := SQL%ROWCOUNT;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF FALSE THEN NULL; -- Placeholder in case no unique indexes
           ELSIF l_name = 'I_EMPLOYEE_NAME'
           THEN
              qd_runtime.register_error (
                 error_name_in => 'DUPLICATE-VALUE'
                ,err_instance_id_out => l_err_instance_id
                ,text_in => 'Violation of unique index "I_EMPLOYEE_NAME"'
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'OWNER'
                ,value_in => l_owner
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'CONSTRAINT_NAME'
                ,value_in => l_name
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'TABLE_NAME'
                ,value_in => 'EMPLOYEE'
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'LAST_NAME'
                ,value_in => last_name_in
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'FIRST_NAME'
                ,value_in => first_name_in
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'MIDDLE_INITIAL'
                ,value_in => middle_initial_in
                ,validate_in => FALSE
                );
              qd_runtime.raise_error_instance (
                    err_instance_id_in => l_err_instance_id);
           ELSE
              qd_runtime.raise_error (
                    error_name_in => 'DUPLICATE-VALUE'
                    ,name1_in => 'OWNER'
                    ,value1_in => l_owner
                    ,name2_in => 'CONSTRAINT_NAME'
                    ,value2_in => l_name
                    ,name3_in => 'TABLE_NAME'
                    ,value3_in => 'EMPLOYEE');
           END IF;
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd;

   PROCEDURE upd (
      rec_in IN EMPLOYEE_TP.EMPLOYEE_rt,
      rows_out OUT PLS_INTEGER,
      ignore_if_null_in IN BOOLEAN := FALSE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      upd (
         employee_id_in => rec_in.EMPLOYEE_ID,
         last_name_in => rec_in.LAST_NAME,
         first_name_in => rec_in.FIRST_NAME,
         middle_initial_in => rec_in.MIDDLE_INITIAL,
         job_id_in => rec_in.JOB_ID,
         manager_id_in => rec_in.MANAGER_ID,
         hire_date_in => rec_in.HIRE_DATE,
         salary_in => rec_in.SALARY,
         commission_in => rec_in.COMMISSION,
         department_id_in => rec_in.DEPARTMENT_ID,
         empno_in => rec_in.EMPNO,
         ename_in => rec_in.ENAME,
         created_by_in => rec_in.CREATED_BY,
         created_on_in => rec_in.CREATED_ON,
         changed_by_in => rec_in.CHANGED_BY,
         changed_on_in => rec_in.CHANGED_ON,
        rows_out => rows_out,
        ignore_if_null_in => ignore_if_null_in,
        handle_error_in => handle_error_in
      );
   END upd;

   PROCEDURE upd_ins (
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      last_name_in IN EMPLOYEE_TP.LAST_NAME_t DEFAULT NULL,
      first_name_in IN EMPLOYEE_TP.FIRST_NAME_t DEFAULT NULL,
      middle_initial_in IN EMPLOYEE_TP.MIDDLE_INITIAL_t DEFAULT NULL,
      job_id_in IN EMPLOYEE_TP.JOB_ID_t DEFAULT NULL,
      manager_id_in IN EMPLOYEE_TP.MANAGER_ID_t DEFAULT NULL,
      hire_date_in IN EMPLOYEE_TP.HIRE_DATE_t DEFAULT NULL,
      salary_in IN EMPLOYEE_TP.SALARY_t DEFAULT NULL,
      commission_in IN EMPLOYEE_TP.COMMISSION_t DEFAULT NULL,
      department_id_in IN EMPLOYEE_TP.DEPARTMENT_ID_t DEFAULT NULL,
      empno_in IN EMPLOYEE_TP.EMPNO_t DEFAULT NULL,
      ename_in IN EMPLOYEE_TP.ENAME_t DEFAULT NULL,
      created_by_in IN EMPLOYEE_TP.CREATED_BY_t DEFAULT NULL,
      created_on_in IN EMPLOYEE_TP.CREATED_ON_t DEFAULT NULL,
      changed_by_in IN EMPLOYEE_TP.CHANGED_BY_t DEFAULT NULL,
      changed_on_in IN EMPLOYEE_TP.CHANGED_ON_t DEFAULT NULL,
      rows_out OUT PLS_INTEGER
     ,ignore_if_null_in IN BOOLEAN := FALSE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
      l_rows PLS_INTEGER;
   BEGIN
      upd (
         employee_id_in => employee_id_in,
         last_name_in => last_name_in,
         first_name_in => first_name_in,
         middle_initial_in => middle_initial_in,
         job_id_in => job_id_in,
         manager_id_in => manager_id_in,
         hire_date_in => hire_date_in,
         salary_in => salary_in,
         commission_in => commission_in,
         department_id_in => department_id_in,
         empno_in => empno_in,
         ename_in => ename_in,
         created_by_in => created_by_in,
         created_on_in => created_on_in,
         changed_by_in => changed_by_in,
         changed_on_in => changed_on_in,
          rows_out => l_rows
         ,ignore_if_null_in => ignore_if_null_in
         ,handle_error_in => handle_error_in
       );
      IF l_rows = 0
      THEN
         ins (
            employee_id_in => employee_id_in,
            last_name_in => last_name_in,
            first_name_in => first_name_in,
            middle_initial_in => middle_initial_in,
            job_id_in => job_id_in,
            manager_id_in => manager_id_in,
            hire_date_in => hire_date_in,
            salary_in => salary_in,
            commission_in => commission_in,
            department_id_in => department_id_in,
            empno_in => empno_in,
            ename_in => ename_in,
            created_by_in => created_by_in,
            created_on_in => created_on_in,
            changed_by_in => changed_by_in,
            changed_on_in => changed_on_in,
            handle_error_in => handle_error_in
         );
         l_rows := 1;
      END IF;
      rows_out := l_rows;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF FALSE THEN NULL; -- Placeholder in case no unique indexes
           ELSIF l_name = 'I_EMPLOYEE_NAME'
           THEN
              qd_runtime.register_error (
                 error_name_in => 'DUPLICATE-VALUE'
                ,err_instance_id_out => l_err_instance_id
                ,text_in => 'Violation of unique index "I_EMPLOYEE_NAME"'
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'OWNER'
                ,value_in => l_owner
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'CONSTRAINT_NAME'
                ,value_in => l_name
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'TABLE_NAME'
                ,value_in => 'EMPLOYEE'
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'LAST_NAME'
                ,value_in => last_name_in
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'FIRST_NAME'
                ,value_in => first_name_in
                ,validate_in => FALSE
                );
              qd_runtime.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'MIDDLE_INITIAL'
                ,value_in => middle_initial_in
                ,validate_in => FALSE
                );
              qd_runtime.raise_error_instance (
                    err_instance_id_in => l_err_instance_id);
           ELSE
              qd_runtime.raise_error (
                    error_name_in => 'DUPLICATE-VALUE'
                    ,name1_in => 'OWNER'
                    ,value1_in => l_owner
                    ,name2_in => 'CONSTRAINT_NAME'
                    ,value2_in => l_name
                    ,name3_in => 'TABLE_NAME'
                    ,value3_in => 'EMPLOYEE');
           END IF;
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd_ins;
   FUNCTION dynupdstr (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      where_in IN VARCHAR2 := NULL)
   RETURN VARCHAR2
   IS
   BEGIN
      RETURN
         'UPDATE EMPLOYEE
             SET ' || colname_in || ' = :value
           WHERE ' || NVL (where_in, '1=1');
   END dynupdstr;
   PROCEDURE upd_onecol (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN VARCHAR2,
      where_in IN VARCHAR2 := NULL,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'upd_onecol');
      END IF;
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
      USING new_value_in;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd_onecol;

    PROCEDURE upd_onecol (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN DATE,
      where_in IN VARCHAR2 := NULL,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'upd_onecol');
      END IF;
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
      USING new_value_in;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd_onecol;

    PROCEDURE upd_onecol (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN NUMBER,
      where_in IN VARCHAR2 := NULL,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'upd_onecol');
      END IF;
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
      USING new_value_in;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd_onecol;
   PROCEDURE upd_onecol_pky (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN VARCHAR2,
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE := UPPER (colname_in);
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'upd_onecol_pky');
      END IF;
      IF l_colname = 'LAST_NAME' THEN
         UPDATE EMPLOYEE
            SET LAST_NAME = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'FIRST_NAME' THEN
         UPDATE EMPLOYEE
            SET FIRST_NAME = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'MIDDLE_INITIAL' THEN
         UPDATE EMPLOYEE
            SET MIDDLE_INITIAL = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'ENAME' THEN
         UPDATE EMPLOYEE
            SET ENAME = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'CREATED_BY' THEN
         UPDATE EMPLOYEE
            SET CREATED_BY = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'CHANGED_BY' THEN
         UPDATE EMPLOYEE
            SET CHANGED_BY = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      <<update_complete>>
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd_onecol_pky;
   PROCEDURE upd_onecol_pky (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN DATE,
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE := UPPER (colname_in);
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'upd_onecol_pky');
      END IF;
      IF l_colname = 'HIRE_DATE' THEN
         UPDATE EMPLOYEE
            SET HIRE_DATE = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'CREATED_ON' THEN
         UPDATE EMPLOYEE
            SET CREATED_ON = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'CHANGED_ON' THEN
         UPDATE EMPLOYEE
            SET CHANGED_ON = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      <<update_complete>>
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd_onecol_pky;
   PROCEDURE upd_onecol_pky (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN NUMBER,
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE := UPPER (colname_in);
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'upd_onecol_pky');
      END IF;
      IF l_colname = 'EMPLOYEE_ID' THEN
         UPDATE EMPLOYEE
            SET EMPLOYEE_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'JOB_ID' THEN
         UPDATE EMPLOYEE
            SET JOB_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'MANAGER_ID' THEN
         UPDATE EMPLOYEE
            SET MANAGER_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'SALARY' THEN
         UPDATE EMPLOYEE
            SET SALARY = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'COMMISSION' THEN
         UPDATE EMPLOYEE
            SET COMMISSION = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'DEPARTMENT_ID' THEN
         UPDATE EMPLOYEE
            SET DEPARTMENT_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_colname = 'EMPNO' THEN
         UPDATE EMPLOYEE
            SET EMPNO = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      <<update_complete>>
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN DUP_VAL_ON_INDEX
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id qd_err_instance_tp.id_t;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           qd_runtime.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END upd_onecol_pky;

    -- Set all non-primary key columns to NULL
   PROCEDURE nullify_row (
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_rows PLS_INTEGER;
   BEGIN
      upd (
         employee_id_in => employee_id_in,
         last_name_in => NULL,
         first_name_in => NULL,
         middle_initial_in => NULL,
         job_id_in => NULL,
         manager_id_in => NULL,
         salary_in => NULL,
         commission_in => NULL,
         department_id_in => NULL,
         empno_in => NULL,
         ename_in => NULL,
          rows_out => l_rows
         ,ignore_if_null_in => FALSE
         ,handle_error_in => handle_error_in
       );
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END nullify_row;

   -- Delete functionality
   PROCEDURE del (
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution (program_name_in => 'del'
            , information_in => EMPLOYEE_ID_in
            );
      END IF;
      DELETE FROM EMPLOYEE
       WHERE
          EMPLOYEE_ID = employee_id_in
         ;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del;

   -- Delete all rows for primary key column EMPLOYEE_ID
   PROCEDURE del_EMPLOYEE_ID (
      employee_id_in IN EMPLOYEE_TP.EMPLOYEE_ID_t
     ,rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
     )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_EMPLOYEE_ID');
      END IF;
      DELETE FROM EMPLOYEE
       WHERE EMPLOYEE_ID = employee_id_in;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_EMPLOYEE_ID;
   -- Delete for unique value of I_EMPLOYEE_NAME
   PROCEDURE del_I_EMPLOYEE_NAME (
      last_name_in IN EMPLOYEE_TP.LAST_NAME_t,
      first_name_in IN EMPLOYEE_TP.FIRST_NAME_t,
      middle_initial_in IN EMPLOYEE_TP.MIDDLE_INITIAL_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_I_EMPLOYEE_NAME');
      END IF;
      DELETE FROM EMPLOYEE
       WHERE
          LAST_NAME = last_name_in AND
          FIRST_NAME = first_name_in AND
          MIDDLE_INITIAL = middle_initial_in
         ;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_I_EMPLOYEE_NAME;

   PROCEDURE del_FK_EMP_DEPARTMENT (
      department_id_in IN EMPLOYEE_TP.DEPARTMENT_ID_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_FK_EMP_DEPARTMENT');
      END IF;
      DELETE FROM EMPLOYEE
       WHERE
          DEPARTMENT_ID = del_FK_EMP_DEPARTMENT.department_id_in
         ;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_FK_EMP_DEPARTMENT;

   PROCEDURE del_FK_EMP_JOB (
      job_id_in IN EMPLOYEE_TP.JOB_ID_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_FK_EMP_JOB');
      END IF;
      DELETE FROM EMPLOYEE
       WHERE
          JOB_ID = del_FK_EMP_JOB.job_id_in
         ;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_FK_EMP_JOB;

   PROCEDURE del_FK_EMP_MANAGER (
      manager_id_in IN EMPLOYEE_TP.MANAGER_ID_t,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_FK_EMP_MANAGER');
      END IF;
      DELETE FROM EMPLOYEE
       WHERE
          MANAGER_ID = del_FK_EMP_MANAGER.manager_id_in
         ;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_FK_EMP_MANAGER;

   -- Deletions using dynamic SQL
   FUNCTION dyndelstr (where_in IN VARCHAR2) RETURN VARCHAR2
   IS
   BEGIN
      IF where_in IS NULL
      THEN
         RETURN 'DELETE FROM EMPLOYEE';
      ELSE
         RETURN
            'DELETE FROM EMPLOYEE WHERE ' || where_in;
      END IF;
   END dyndelstr;

   FUNCTION dyncoldelstr (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN dyndelstr ( colname_in || ' = :value' );
   END;

   PROCEDURE del_by (
      where_clause_in IN VARCHAR2
     ,rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution (program_name_in => 'del_by');
      END IF;
      EXECUTE IMMEDIATE dyndelstr (where_clause_in);
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => NULL
             ,value1_in => NULL
             ,name2_in => NULL
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_by;

   PROCEDURE del_by_col (
      colname_in IN VARCHAR2,
      colvalue_in IN VARCHAR2,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE)
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_by_col');
      END IF;
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
         USING colvalue_in;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => 'COLUMN_NAME'
             ,value1_in => NULL
             ,name2_in => 'COLUMN_VALUE'
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_by_col;

   PROCEDURE del_by_col (
      colname_in IN VARCHAR2,
      colvalue_in IN DATE,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_by_col');
      END IF;
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
         USING colvalue_in;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => 'COLUMN_NAME'
             ,value1_in => NULL
             ,name2_in => 'COLUMN_VALUE'
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_by_col;

   PROCEDURE del_by_col (
      colname_in IN VARCHAR2,
      colvalue_in IN NUMBER,
      rows_out OUT PLS_INTEGER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      IF qd_runtime.trace_enabled THEN
         qd_runtime.start_execution(program_name_in => 'del_by_col');
      END IF;
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
         USING colvalue_in;
      rows_out := SQL%ROWCOUNT;
      IF qd_runtime.trace_enabled THEN
         qd_runtime.end_execution;
      END IF;
   EXCEPTION

      WHEN e_check_constraint_failure
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'NO-PARENT-KEY-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN e_child_record_found
      THEN
        qd_runtime.start_exception_handling;
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           qd_runtime.raise_error (
              error_name_in => 'CHILD-RECORD-FOUND'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEE');
        END;
        END IF;
      WHEN OTHERS THEN
         qd_runtime.start_exception_handling;
         IF NOT handle_error_in THEN RAISE;
         ELSE
           qd_runtime.raise_error (
              error_name_in => 'UNANTICIPATED-ERROR'
             ,name1_in => 'COLUMN_NAME'
             ,value1_in => NULL
             ,name2_in => 'COLUMN_VALUE'
             ,value2_in => NULL
             ,name3_in => NULL
             ,value3_in => NULL
             ,name4_in => NULL
             ,value4_in => NULL
             ,name5_in => NULL
             ,value5_in => NULL
           );
         END IF;
   END del_by_col;
BEGIN
   NULL;
END EMPLOYEE_CP;
/
